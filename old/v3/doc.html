<!DOCTYPE html><html><head><style>body { background:#333; color:#0F0; font-family:Arial,Verdana;} a { color:#0AA } h1 { color:#FF0; } h2 { color:#0FF } table,tr,td { color: #CCC; padding:4px;border:1px solid white; border-collapse:collapse; }</style></head><body>
<a name="CachedQuery"></a>
<hr><h1>CachedQuery</h1>
<p><h3>Extends Query</h3></p>
<p>Query which caches. This extends the normal always-calculate Query class, creating two extra members, a key which can be used to uniquely identify any query, and a table where the keys are the component references. The latter is so the query checker can answer the question very quickly, does this query contains this component (by testing for the key existence)</p>
<p>Methods : <a href="#CachedQuery_(constructor)"/>(constructor)</a>,<a href="#CachedQuery_query"/>query</a>,<a href="#CachedQuery_remove"/>remove</a></p><hr><a name="CachedQuery_(constructor)"></a>
<h2>(constructor)(comet,query)</h2>
<table>
<tr><td>comet</td><td>Comet</td><td>comet object</td></tr>
<tr><td>query</td><td>string, Component, table</td><td>A name or CSV Names, a single component, or a list of query, that go to make up the query.</td></tr>
</table>
<p>Prepare a cached query. Queries are immutable in terms of what they are querying on.</p>
<a name="CachedQuery_query"></a>
<h2>query()</h2>
<table>
<tr><td>return</td><td>table</td><td>List of entities satisfying that query.</td></tr>
</table>
<p>Execute a query, accessing the cache if there is something in the cache and it is still valud.</p>
<a name="CachedQuery_remove"></a>
<h2>remove()</h2>
<p>Clean up a cached query object.</p>
<a name="Comet"></a>
<hr><h1>Comet</h1>
<p><h3>Extends Base</h3></p>
<p>Comet class. This is the manager of the current set of entities, components and systems.</p>
<p>Methods : <a href="#Comet_(constructor)"/>(constructor)</a>,<a href="#Comet_getComponentByName"/>getComponentByName</a>,<a href="#Comet_newC"/>newC</a>,<a href="#Comet_newE"/>newE</a>,<a href="#Comet_newQ"/>newQ</a>,<a href="#Comet_newS"/>newS</a>,<a href="#Comet_remove"/>remove</a>,<a href="#Comet_updateSystems"/>updateSystems</a></p><hr><a name="Comet_(constructor)"></a>
<h2>(constructor)()</h2>
<p>Initialise the Comet object</p>
<a name="Comet_createList"></a>
<a name="Comet_getComponentByName"></a>
<h2>getComponentByName(name)</h2>
<table>
<tr><td>name</td><td>string</td><td>Name of required component</td></tr>
<tr><td>return</td><td>component</td><td>Component object. Throws error on not found.</td></tr>
</table>
<p>Find a component by name</p>
<a name="Comet_getInvalidateCacheAndReset"></a>
<a name="Comet_getQueryCache"></a>
<a name="Comet_invalidateCache"></a>
<a name="Comet_newC"></a>
<h2>newC(name,source)</h2>
<table>
<tr><td>name</td><td>string</td><td>Component Name (optional parameter, can be name in source table)</td></tr>
<tr><td>source</td><td>table/object</td><td>Table, Class or Instance being used to create the component.</td></tr>
</table>
<p>Create a new component. Uses component.new effectively, but shorthand</p>
<a name="Comet_newE"></a>
<h2>newE(name,info)</h2>
<table>
<tr><td>name</td><td>string</td><td>Component Name (optional parameter, can be name in source table)</td></tr>
<tr><td>info</td><td>table/object</td><td>Table, Class or Instance being used to create the component.</td></tr>
</table>
<p>Create a new entity. Uses entity.new effectively, but shorthand</p>
<a name="Comet_newQ"></a>
<h2>newQ(query)</h2>
<table>
<tr><td>query</td><td>table/object</td><td>Table, Class or Instance being used to create the query</td></tr>
</table>
<p>Create a new query. Uses CachedQuery.new effectively, but shorthand.</p>
<a name="Comet_newS"></a>
<h2>newS(query,updater)</h2>
<table>
<tr><td>query</td><td>string, Component, table</td><td>A name or CSV Names, a single component, or a list of query, that go to make up the query.</td></tr>
<tr><td>updater</td><td>function/table/class</td><td>If a function, it is a standalone update, otherwise a collection of methods.</td></tr>
</table>
<p>Create a new System. Uses System.new</p>
<a name="Comet_processList"></a>
<a name="Comet_registerSystem"></a>
<a name="Comet_remove"></a>
<h2>remove()</h2>
<p>Delete the Comet object</p>
<a name="Comet_updateSystems"></a>
<h2>updateSystems()</h2>
<p>Update all systems.</p>
<a name="Component"></a>
<hr><h1>Component</h1>
<p><h3>Extends Base</h3></p>
<p>Component Class. This is a Hybrid system so Components and contain Methods, Message Recipients, Constructors, Destructors and anything else you like. Components are built out of tables containing member variables they use, functions they use, and requires (the components that are required), and a constructor and destructor method (the last three are optional). All methods are called with the first two parameters being self (the entity reference) and private (the components private members). Components can be constructed simply out of tables, or from classes. Constructors and Destructors do not take any parameters.</p>
<p>Methods : <a href="#Component_(constructor)"/>(constructor)</a>,<a href="#Component_toString"/>toString</a></p><hr><a name="Component_(constructor)"></a>
<h2>(constructor)(comet,name,info)</h2>
<table>
<tr><td>comet</td><td>Comet</td><td>Comet object being added to.</td></tr>
<tr><td>name</td><td>string</td><td>Component Name (optional parameter, can be name in source table)</td></tr>
<tr><td>info</td><td>table/object</td><td>Table, Class or Instance being used to create the component.</td></tr>
</table>
<p>Component constructor. Takes a table containing members, functions, and optionsl require, constructor and destructor methods. Any member or function preceded with an underscore is not added to the component.</p>
<a name="Component_addInfo"></a>
<a name="Component_addItem"></a>
<a name="Component_toString"></a>
<h2>toString()</h2>
<table>
<tr><td>return</td><td>string</td><td>String representation of component.</td></tr>
</table>
<p>Convert the component to a string</p>
<a name="Entity"></a>
<hr><h1>Entity</h1>
<p><h3>Extends Base</h3></p>
<p>An entity is a collection of components that can have things added to and removed from them arbitrarily to form working entities. An entity is class in its own right and as such could be subclassed to provide a factory for entities rather than using individual factory methods, or as part of a factory pattern.</p>
<p>Methods : <a href="#Entity_(constructor)"/>(constructor)</a>,<a href="#Entity_addC"/>addC</a>,<a href="#Entity_remC"/>remC</a>,<a href="#Entity_remove"/>remove</a>,<a href="#Entity_toString"/>toString</a></p><hr><a name="Entity_(constructor)"></a>
<h2>(constructor)(comet,initial,components)</h2>
<table>
<tr><td>comet</td><td>Comet</td><td>comet object</td></tr>
<tr><td>initial</td><td>table</td><td>Initialisation values for members.</td></tr>
<tr><td>components</td><td>string, Component, table</td><td>A name or CSV Names, a single component, or a list of components.</td></tr>
</table>
<p>Entity constructor. Takes a parent comet object and a list of components, which is optional - empty entites are allowable, but don't make much sense.</p>
<a name="Entity_addC"></a>
<h2>addC(components)</h2>
<table>
<tr><td>components</td><td>string, Component, table</td><td>A name or CSV Names, a single component, or a list of components.</td></tr>
<tr><td>return</td><td>self</td><td>Chainable</td></tr>
</table>
<p>Add a collection of components (which may take various forms)</p>
<a name="Entity_addComponentByReference"></a>
<a name="Entity_initialiseMembers"></a>
<a name="Entity_methodCall"></a>
<a name="Entity_remC"></a>
<h2>remC(components)</h2>
<table>
<tr><td>components</td><td>string, Component, table</td><td>A name or CSV Names, a single component, or a list of components.</td></tr>
<tr><td>return</td><td>self</td><td>Chainable</td></tr>
</table>
<p>Remove a collection of components, or a component from the entity.</p>
<a name="Entity_remove"></a>
<h2>remove()</h2>
<p>Remove an entire entity. Repeated removes are harmless.</p>
<a name="Entity_removeComponentByReference"></a>
<a name="Entity_toString"></a>
<h2>toString()</h2>
<table>
<tr><td>return</td><td>string</td><td>String representation of entity</td></tr>
</table>
<p>Convert an entity to a string representation</p>
<a name="Query"></a>
<hr><h1>Query</h1>
<p><h3>Extends Base</h3></p>
<p>Non-cached query class. Maintains a query which is immutable, and calculates the result set.</p>
<p>Methods : <a href="#Query_(constructor)"/>(constructor)</a>,<a href="#Query_query"/>query</a>,<a href="#Query_remove"/>remove</a></p><hr><a name="Query_(constructor)"></a>
<h2>(constructor)(comet,query)</h2>
<table>
<tr><td>comet</td><td>Comet</td><td>comet object</td></tr>
<tr><td>query</td><td>string, Component, table</td><td>A name or CSV Names, a single component, or a list of query, that go to make up the query.</td></tr>
</table>
<p>Prepare a query. Queries are immutable in terms of what they are querying on.</p>
<a name="Query_query"></a>
<h2>query()</h2>
<table>
<tr><td>return</td><td>table</td><td>List of entities satisfying that query.</td></tr>
</table>
<p>Execute a query.</p>
<a name="Query_remove"></a>
<h2>remove()</h2>
<p>Clean up a query object.</p>
<a name="QueryCache"></a>
<hr><h1>QueryCache</h1>
<p><h3>Extends Base</h3></p>
<p>Query Cache. Maintains two tables, a cache of a result and a list of the components used in the query (in the keys of the table), and tracks whether the cached query can be reused.</p>
<p>Methods : <a href="#QueryCache_(constructor)"/>(constructor)</a>,<a href="#QueryCache_access"/>access</a>,<a href="#QueryCache_remove"/>remove</a>,<a href="#QueryCache_update"/>update</a></p><hr><a name="QueryCache_(constructor)"></a>
<h2>(constructor)(comet)</h2>
<table>
<tr><td>comet</td><td>Comet</td><td>comet object</td></tr>
</table>
<p>Initialise the query cache.</p>
<a name="QueryCache_access"></a>
<h2>access(queryKey)</h2>
<table>
<tr><td>queryKey</td><td>string</td><td>Unique identifier for any query</td></tr>
</table>
<p>Cache access check. First it gets the list of the components that are invalid - i.e. have been added or removed from an entity (because any query featuring those components will have changed its result) and scans through the cache looking for queries that have any of those components they are consequently invalidated.</p>
<a name="QueryCache_remove"></a>
<h2>remove()</h2>
<p>Close and tidy up. Also (optionally using comment) prints the cache efficiency on the debug screen.</p>
<a name="QueryCache_update"></a>
<h2>update(queryKey,queryResult,queryComponents)</h2>
<table>
<tr><td>queryKey</td><td>string</td><td>Unique identifier for any query</td></tr>
<tr><td>queryResult</td><td>table</td><td>List of entities from successful query</td></tr>
<tr><td>queryComponents</td><td>table</td><td>List of components used in that query (component ref -> <true>)</td></tr>
</table>
<p>Update the key with a new result</p>
<a name="System"></a>
<hr><h1>System</h1>
<p><h3>Extends Base</h3></p>
<p></p>
<p>Methods : <a href="#System_(constructor)"/>(constructor)</a>,<a href="#System_remove"/>remove</a>,<a href="#System_update"/>update</a></p><hr><a name="System_(constructor)"></a>
<h2>(constructor)(comet,query,updater)</h2>
<table>
<tr><td>comet</td><td>Comet</td><td>comet object</td></tr>
<tr><td>query</td><td>string, Component, table</td><td>A name or CSV Names, a single component, or a list of query, that go to make up the query.</td></tr>
<tr><td>updater</td><td>function/table/class</td><td>If a function, it is a standalone update, otherwise a collection of methods.</td></tr>
</table>
<p>System Constructor.</p>
<a name="System_remove"></a>
<h2>remove()</h2>
<p>Remove a system.</p>
<a name="System_update"></a>
<h2>update()</h2>
<p>Update a system.</p>
<hr><p><i>LUA Autodoc by Paul Robson 2014</i></p><hr></body></html>
